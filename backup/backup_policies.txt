20250602045640	{"\n-- Create products table for t-shirt variants\nCREATE TABLE IF NOT EXISTS public.products (\n  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n  name TEXT NOT NULL,\n  description TEXT,\n  base_price DECIMAL(10,2) NOT NULL,\n  category TEXT DEFAULT 'tshirt',\n  sizes JSONB DEFAULT '[\\"S\\", \\"M\\", \\"L\\", \\"XL\\", \\"XXL\\"]'::jsonb,\n  colors JSONB DEFAULT '[\\"#FFFFFF\\", \\"#000000\\", \\"#8A898C\\", \\"#1EAEDB\\"]'::jsonb,\n  is_active BOOLEAN DEFAULT true,\n  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()\n);\n\n-- Add Row Level Security to cart_items table (if not already enabled)\nALTER TABLE public.cart_items ENABLE ROW LEVEL SECURITY;\n\n-- Drop existing policies if they exist and recreate them\nDROP POLICY IF EXISTS \\"Users can view their own cart items\\" ON public.cart_items;\nDROP POLICY IF EXISTS \\"Users can create their own cart items\\" ON public.cart_items;\nDROP POLICY IF EXISTS \\"Users can update their own cart items\\" ON public.cart_items;\nDROP POLICY IF EXISTS \\"Users can delete their own cart items\\" ON public.cart_items;\n\n-- Create policies for cart_items\nCREATE POLICY \\"Users can view their own cart items\\" \n  ON public.cart_items \n  FOR SELECT \n  USING (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can create their own cart items\\" \n  ON public.cart_items \n  FOR INSERT \n  WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can update their own cart items\\" \n  ON public.cart_items \n  FOR UPDATE \n  USING (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can delete their own cart items\\" \n  ON public.cart_items \n  FOR DELETE \n  USING (auth.uid() = user_id);\n\n-- Make products publicly readable\nALTER TABLE public.products ENABLE ROW LEVEL SECURITY;\nDROP POLICY IF EXISTS \\"Products are publicly readable\\" ON public.products;\nCREATE POLICY \\"Products are publicly readable\\" \n  ON public.products \n  FOR SELECT \n  USING (is_active = true);\n\n-- Insert sample products (only if table is empty)\nINSERT INTO public.products (name, description, base_price, category) \nSELECT * FROM (VALUES\n  ('Classic Cotton Tee', 'Premium 100% cotton t-shirt, perfect for custom designs', 24.99, 'tshirt'),\n  ('Premium Blend Tee', 'Soft cotton-polyester blend for comfort and durability', 29.99, 'tshirt'),\n  ('Organic Cotton Tee', 'Eco-friendly organic cotton t-shirt', 32.99, 'tshirt')\n) AS new_products(name, description, base_price, category)\nWHERE NOT EXISTS (SELECT 1 FROM public.products);\n"}	60e7dc89-ae33-4f47-8935-b5ed7da200c9	kmandalam@gmail.com	\N
20250602051905	{"\n-- Create orders table to store order information\nCREATE TABLE public.orders (\n  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id UUID NOT NULL,\n  order_number TEXT NOT NULL UNIQUE,\n  total_amount DECIMAL(10,2) NOT NULL,\n  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'shipped', 'delivered', 'cancelled')),\n  shipping_address_id UUID,\n  shipping_address JSONB NOT NULL,\n  payment_method TEXT,\n  notes TEXT,\n  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()\n);\n\n-- Create order_items table to store individual items in each order\nCREATE TABLE public.order_items (\n  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n  order_id UUID NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,\n  product_id TEXT NOT NULL,\n  quantity INTEGER NOT NULL DEFAULT 1,\n  unit_price DECIMAL(10,2) NOT NULL,\n  total_price DECIMAL(10,2) NOT NULL,\n  design_data JSONB,\n  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()\n);\n\n-- Add Row Level Security (RLS) to orders table\nALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;\n\n-- Create policies for orders table\nCREATE POLICY \\"Users can view their own orders\\" \n  ON public.orders \n  FOR SELECT \n  USING (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can create their own orders\\" \n  ON public.orders \n  FOR INSERT \n  WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can update their own orders\\" \n  ON public.orders \n  FOR UPDATE \n  USING (auth.uid() = user_id);\n\n-- Add Row Level Security (RLS) to order_items table\nALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;\n\n-- Create policies for order_items table\nCREATE POLICY \\"Users can view their own order items\\" \n  ON public.order_items \n  FOR SELECT \n  USING (EXISTS (\n    SELECT 1 FROM public.orders \n    WHERE orders.id = order_items.order_id \n    AND orders.user_id = auth.uid()\n  ));\n\nCREATE POLICY \\"Users can create their own order items\\" \n  ON public.order_items \n  FOR INSERT \n  WITH CHECK (EXISTS (\n    SELECT 1 FROM public.orders \n    WHERE orders.id = order_items.order_id \n    AND orders.user_id = auth.uid()\n  ));\n\n-- Create function to generate order numbers\nCREATE OR REPLACE FUNCTION generate_order_number()\nRETURNS TEXT AS $$\nBEGIN\n  RETURN 'ORD-' || TO_CHAR(NOW(), 'YYYYMMDD') || '-' || LPAD(NEXTVAL('order_number_seq')::TEXT, 6, '0');\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create sequence for order numbers\nCREATE SEQUENCE IF NOT EXISTS order_number_seq START 1;\n\n-- Create function to automatically set order number on insert\nCREATE OR REPLACE FUNCTION set_order_number()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.order_number IS NULL OR NEW.order_number = '' THEN\n    NEW.order_number := generate_order_number();\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create trigger to set order number\nCREATE TRIGGER set_order_number_trigger\n  BEFORE INSERT ON public.orders\n  FOR EACH ROW\n  EXECUTE FUNCTION set_order_number();\n\n-- Create function to update updated_at timestamp\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create trigger to update updated_at on orders\nCREATE TRIGGER update_orders_updated_at\n  BEFORE UPDATE ON public.orders\n  FOR EACH ROW\n  EXECUTE FUNCTION update_updated_at_column();\n"}	743b5313-79df-467d-9fe2-d87553cd2796	kmandalam@gmail.com	\N
20250603055901	{"\n-- Create custom_designs table to store user-created designs from the design page\nCREATE TABLE public.custom_designs (\n  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id UUID NOT NULL REFERENCES auth.users(id),\n  design_name TEXT NOT NULL,\n  design_data JSONB NOT NULL, -- Canvas data from the design tools\n  design_image TEXT NOT NULL, -- Base64 or URL of the design preview\n  tshirt_color TEXT NOT NULL DEFAULT '#FFFFFF',\n  base_price NUMERIC NOT NULL DEFAULT 29.99,\n  theme_name TEXT, -- Store theme used for design\n  answers JSONB, -- Store design preferences/answers\n  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()\n);\n\n-- Create payment_transactions table for detailed payment tracking\nCREATE TABLE public.payment_transactions (\n  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n  order_id UUID NOT NULL REFERENCES orders(id),\n  payment_gateway TEXT NOT NULL, -- 'razorpay', 'stripe', etc.\n  gateway_transaction_id TEXT NOT NULL,\n  payment_method TEXT NOT NULL, -- 'upi', 'card', 'netbanking', 'wallet'\n  upi_transaction_id TEXT, -- Specific UPI transaction reference\n  upi_id TEXT, -- Customer's UPI ID used for payment\n  amount NUMERIC NOT NULL,\n  currency TEXT NOT NULL DEFAULT 'INR',\n  status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'success', 'failed', 'cancelled'\n  gateway_response JSONB, -- Full response from payment gateway\n  failure_reason TEXT, -- If payment failed, store reason\n  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()\n);\n\n-- Add custom_design_id to order_items to link to custom designs\nALTER TABLE public.order_items \nADD COLUMN custom_design_id UUID REFERENCES custom_designs(id);\n\n-- Add payment_transaction_id to orders for easy reference\nALTER TABLE public.orders \nADD COLUMN payment_transaction_id UUID REFERENCES payment_transactions(id);\n\n-- Enable RLS on custom_designs table\nALTER TABLE public.custom_designs ENABLE ROW LEVEL SECURITY;\n\n-- RLS policies for custom_designs\nCREATE POLICY \\"Users can view their own custom designs\\" \n  ON public.custom_designs \n  FOR SELECT \n  USING (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can create their own custom designs\\" \n  ON public.custom_designs \n  FOR INSERT \n  WITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can update their own custom designs\\" \n  ON public.custom_designs \n  FOR UPDATE \n  USING (auth.uid() = user_id);\n\nCREATE POLICY \\"Users can delete their own custom designs\\" \n  ON public.custom_designs \n  FOR DELETE \n  USING (auth.uid() = user_id);\n\n-- Enable RLS on payment_transactions table\nALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;\n\n-- RLS policies for payment_transactions (users can only see their own payment transactions)\nCREATE POLICY \\"Users can view their own payment transactions\\" \n  ON public.payment_transactions \n  FOR SELECT \n  USING (auth.uid() = (SELECT user_id FROM orders WHERE orders.id = order_id));\n\n-- Create indexes for better performance\nCREATE INDEX idx_custom_designs_user_id ON public.custom_designs(user_id);\nCREATE INDEX idx_payment_transactions_order_id ON public.payment_transactions(order_id);\nCREATE INDEX idx_payment_transactions_gateway_transaction_id ON public.payment_transactions(gateway_transaction_id);\nCREATE INDEX idx_payment_transactions_status ON public.payment_transactions(status);\n\n-- Create trigger to update updated_at column\nCREATE OR REPLACE FUNCTION update_custom_designs_updated_at()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_update_custom_designs_updated_at\n  BEFORE UPDATE ON public.custom_designs\n  FOR EACH ROW\n  EXECUTE FUNCTION update_custom_designs_updated_at();\n\nCREATE TRIGGER trigger_update_payment_transactions_updated_at\n  BEFORE UPDATE ON public.payment_transactions\n  FOR EACH ROW\n  EXECUTE FUNCTION update_updated_at_column();\n"}	ab140ec1-0e77-4823-8624-82d066d25e27	kmandalam@gmail.com	\N
20250715081133	{"-- Phase 1: Create New Database Structure for Product Variants System\n-- This creates new tables alongside existing ones (no data loss risk)\n\n-- Create product_categories table for better organization\nCREATE TABLE IF NOT EXISTS public.product_categories (\n  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n  name TEXT NOT NULL UNIQUE,\n  description TEXT,\n  is_active BOOLEAN NOT NULL DEFAULT true,\n  sort_order INTEGER DEFAULT 0,\n  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()\n);\n\n-- Create product_variants table for individual SKUs\nCREATE TABLE IF NOT EXISTS public.product_variants (\n  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n  product_id UUID NOT NULL,\n  sku TEXT NOT NULL UNIQUE,\n  color_name TEXT NOT NULL,\n  color_hex TEXT NOT NULL,\n  size TEXT NOT NULL,\n  price NUMERIC(10,2) NOT NULL,\n  stock_quantity INTEGER NOT NULL DEFAULT 0,\n  low_stock_threshold INTEGER DEFAULT 5,\n  is_active BOOLEAN NOT NULL DEFAULT true,\n  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),\n  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),\n  \n  -- Foreign key to products table\n  CONSTRAINT fk_product_variants_product_id \n    FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE CASCADE,\n    \n  -- Ensure unique combination of product, color, and size\n  CONSTRAINT unique_product_color_size \n    UNIQUE (product_id, color_hex, size)\n);\n\n-- Add category_id to products table (nullable for backward compatibility)\nALTER TABLE public.products \nADD COLUMN IF NOT EXISTS category_id UUID REFERENCES public.product_categories(id);\n\n-- Create indexes for performance\nCREATE INDEX IF NOT EXISTS idx_product_variants_product_id ON public.product_variants(product_id);\nCREATE INDEX IF NOT EXISTS idx_product_variants_sku ON public.product_variants(sku);\nCREATE INDEX IF NOT EXISTS idx_product_variants_active ON public.product_variants(is_active);\nCREATE INDEX IF NOT EXISTS idx_product_variants_stock ON public.product_variants(stock_quantity);\n\n-- Enable RLS on new tables\nALTER TABLE public.product_categories ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.product_variants ENABLE ROW LEVEL SECURITY;\n\n-- RLS Policies for product_categories (public read access)\nCREATE POLICY \\"Categories are publicly readable\\" \nON public.product_categories \nFOR SELECT \nUSING (is_active = true);\n\n-- RLS Policies for product_variants (public read access for active variants)\nCREATE POLICY \\"Product variants are publicly readable\\" \nON public.product_variants \nFOR SELECT \nUSING (is_active = true);\n\n-- Create triggers for automatic timestamp updates\nCREATE TRIGGER update_product_categories_updated_at\n  BEFORE UPDATE ON public.product_categories\n  FOR EACH ROW\n  EXECUTE FUNCTION public.update_updated_at_column();\n\nCREATE TRIGGER update_product_variants_updated_at\n  BEFORE UPDATE ON public.product_variants\n  FOR EACH ROW\n  EXECUTE FUNCTION public.update_updated_at_column();\n\n-- Create validation functions for data integrity\nCREATE OR REPLACE FUNCTION public.validate_migration_data()\nRETURNS TABLE(\n  check_name TEXT,\n  status TEXT,\n  count_value BIGINT,\n  details TEXT\n) \nLANGUAGE plpgsql\nAS $$\nBEGIN\n  -- Check existing products count\n  RETURN QUERY SELECT \n    'existing_products'::TEXT,\n    'info'::TEXT,\n    COUNT(*)::BIGINT,\n    'Total products in current system'::TEXT\n  FROM public.products;\n  \n  -- Check existing cart items count\n  RETURN QUERY SELECT \n    'existing_cart_items'::TEXT,\n    'info'::TEXT,\n    COUNT(*)::BIGINT,\n    'Total cart items in current system'::TEXT\n  FROM public.cart_items;\n  \n  -- Check existing order items count\n  RETURN QUERY SELECT \n    'existing_order_items'::TEXT,\n    'info'::TEXT,\n    COUNT(*)::BIGINT,\n    'Total order items in current system'::TEXT\n  FROM public.order_items;\n  \n  -- Validate JSON structure in products\n  RETURN QUERY SELECT \n    'products_with_valid_colors'::TEXT,\n    'validation'::TEXT,\n    COUNT(*)::BIGINT,\n    'Products with valid color JSON arrays'::TEXT\n  FROM public.products \n  WHERE jsonb_typeof(colors) = 'array';\n  \n  -- Validate JSON structure for sizes\n  RETURN QUERY SELECT \n    'products_with_valid_sizes'::TEXT,\n    'validation'::TEXT,\n    COUNT(*)::BIGINT,\n    'Products with valid size JSON arrays'::TEXT\n  FROM public.products \n  WHERE jsonb_typeof(sizes) = 'array';\n  \n  -- Calculate expected variants count\n  RETURN QUERY SELECT \n    'expected_variants_total'::TEXT,\n    'calculation'::TEXT,\n    SUM(jsonb_array_length(colors) * jsonb_array_length(sizes))::BIGINT,\n    'Total variants that will be created'::TEXT\n  FROM public.products \n  WHERE jsonb_typeof(colors) = 'array' AND jsonb_typeof(sizes) = 'array';\n  \nEND;\n$$;\n\n-- Create function to generate SKU\nCREATE OR REPLACE FUNCTION public.generate_variant_sku(\n  product_name TEXT,\n  color_name TEXT,\n  size_name TEXT\n)\nRETURNS TEXT\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  clean_product_name TEXT;\n  clean_color_name TEXT;\n  clean_size_name TEXT;\n  sku_base TEXT;\nBEGIN\n  -- Clean and normalize names\n  clean_product_name := UPPER(REGEXP_REPLACE(TRIM(product_name), '[^A-Za-z0-9]', '', 'g'));\n  clean_color_name := UPPER(REGEXP_REPLACE(TRIM(color_name), '[^A-Za-z0-9]', '', 'g'));\n  clean_size_name := UPPER(TRIM(size_name));\n  \n  -- Take first 3 chars of product name, first 3 of color, and size\n  sku_base := LEFT(clean_product_name, 3) || '-' || LEFT(clean_color_name, 3) || '-' || clean_size_name;\n  \n  RETURN sku_base;\nEND;\n$$;\n\n-- Create color name mapping function\nCREATE OR REPLACE FUNCTION public.get_color_name_from_hex(hex_color TEXT)\nRETURNS TEXT\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  CASE UPPER(hex_color)\n    WHEN '#FFFFFF' THEN RETURN 'White';\n    WHEN '#000000' THEN RETURN 'Black';\n    WHEN '#8A898C' THEN RETURN 'Grey';\n    WHEN '#1EAEDB' THEN RETURN 'Blue';\n    ELSE RETURN 'Color-' || UPPER(REPLACE(hex_color, '#', ''));\n  END CASE;\nEND;\n$$;\n\n-- Insert default product categories\nINSERT INTO public.product_categories (name, description, sort_order) VALUES \n  ('T-Shirts', 'Classic and premium t-shirts', 1),\n  ('Custom Designs', 'User-created custom designs', 2)\nON CONFLICT (name) DO NOTHING;\n\n-- Create a backup verification query function\nCREATE OR REPLACE FUNCTION public.create_migration_checkpoint()\nRETURNS TABLE(\n  checkpoint_name TEXT,\n  table_name TEXT,\n  record_count BIGINT,\n  timestamp_taken TIMESTAMP WITH TIME ZONE\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RETURN QUERY SELECT \n    'pre_migration'::TEXT,\n    'products'::TEXT,\n    COUNT(*)::BIGINT,\n    NOW()\n  FROM public.products;\n  \n  RETURN QUERY SELECT \n    'pre_migration'::TEXT,\n    'cart_items'::TEXT,\n    COUNT(*)::BIGINT,\n    NOW()\n  FROM public.cart_items;\n  \n  RETURN QUERY SELECT \n    'pre_migration'::TEXT,\n    'order_items'::TEXT,\n    COUNT(*)::BIGINT,\n    NOW()\n  FROM public.order_items;\nEND;\n$$;"}		kmandalam@gmail.com	\N
Allow authenticated users to upload design assets
Allow everyone to view questions
Allow everyone to view themes
Allow public read access to design assets
Allow users to delete their own design assets
Allow users to delete their own designs
Allow users to insert their own designs
Allow users to insert their own responses
Allow users to update their own design assets
Allow users to update their own designs
Allow users to update their own profile
Allow users to view all profiles
Allow users to view their own designs
Allow users to view their own responses
Categories are publicly readable
Product variants are publicly readable
Products are publicly readable
Users can create their own AI designs
Users can create their own cart items
Users can create their own custom designs
Users can create their own order items
Users can create their own orders
Users can delete their own AI designs
Users can delete their own addresses
Users can delete their own cart items
Users can delete their own custom designs
Users can insert their own addresses
Users can insert their own cart items
Users can update their own AI designs
Users can update their own addresses
Users can update their own cart items
Users can update their own custom designs
Users can update their own orders
Users can view their own AI designs
Users can view their own addresses
Users can view their own cart items
Users can view their own custom designs
Users can view their own order items
Users can view their own orders
Users can view their own payment transactions
